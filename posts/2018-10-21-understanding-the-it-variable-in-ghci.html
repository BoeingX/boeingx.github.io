<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-73013152-3"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-73013152-3');
        </script>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width" />

        <title>BoeingX - Understanding the "it" variable in GHCi</title>

        <!-- Stylesheets. -->
        <link rel="stylesheet" type="text/css" href="../style.css" />

        <!-- Metadata. -->
        <meta name="keywords" content="Baoyang SONG,boeingx,blog,programming,coding,haskell,function,personal,homepage" />
        <meta name="description" content="Personal home page and blog of BoeingX." />
    </head>
    <body>
        <div id="navigation">
            <h1>Codopia</h1>
            <a href="../">Home</a>
            <a href="../posts.html">Archive</a>
            <a href="../contact.html">Contact</a>
            <h1>Links</h1>
            <a href="https://github.com/BoeingX">GitHub</a>
            <a href="https://www.linkedin.com/in/baoyang-song">LinkedIn</a>
        </div>

        <div id="content">
    <h1>Understanding the "it" variable in GHCi</h1>
<div class="soft">
    <em> The mythical "it" variable in GHCi explained</em>
    <br />
    <br />
    Published on October 21, 2018 under the tag <a href="../tags/haskell.html">haskell</a>
</div>

<h3 id="introduction">Introduction</h3>
<p>As we are told from the very beginning, Haskell is a <a href="https://en.wikipedia.org/wiki/Purely_functional_programming">purely functional</a>, strongly <a href="https://en.wikipedia.org/wiki/Static_typing">statically typed</a> programming language.</p>
<p>By purely functional, we mean that everything is <em>mostly</em> immutable. In non-pure languages like C++ or Python, it is perfectly OK to set a variable <code>a</code> to the value <code>1</code> and then to the value <code>2</code> later. The following Haskell code does not compile</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1">a <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-2" title="2">a <span class="fu">=</span> <span class="dv">2</span></a></code></pre></div>
<p>because GHC complains the “multiple declaration of <code>a</code>”.</p>
<p>Strongly statically typed, on the otherhand, means that it is not possible to compare a Bool with a Char. What’s more, there is no implicit <a href="https://en.wikipedia.org/wiki/Type_conversion">type coercion</a> in that we cannot use <code>1</code> as <code>True</code> and <code>0</code> as <code>False</code>.</p>
<p>So far, so good.</p>
<p>Until one day, when playing with GHCi we realized that the “magic” variable <code>it</code> refers always to the value of the last <strong>successful</strong> expression. The following examples illustrates this behavior.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="dv">3</span></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> it</a>
<a class="sourceLine" id="cb2-4" title="4"><span class="dv">3</span></a>
<a class="sourceLine" id="cb2-5" title="5"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="ch">'a'</span></a>
<a class="sourceLine" id="cb2-6" title="6"><span class="ch">'a'</span></a>
<a class="sourceLine" id="cb2-7" title="7"><span class="dt">Prelude</span><span class="fu">&gt;</span> it</a>
<a class="sourceLine" id="cb2-8" title="8"><span class="ch">'a'</span></a>
<a class="sourceLine" id="cb2-9" title="9"><span class="co">-- We type it again</span></a>
<a class="sourceLine" id="cb2-10" title="10"><span class="dt">Prelude</span><span class="fu">&gt;</span> it</a>
<a class="sourceLine" id="cb2-11" title="11"><span class="ch">'a'</span></a>
<a class="sourceLine" id="cb2-12" title="12"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb2-13" title="13"><span class="dt">True</span></a>
<a class="sourceLine" id="cb2-14" title="14"><span class="dt">Prelude</span><span class="fu">&gt;</span> it</a>
<a class="sourceLine" id="cb2-15" title="15"><span class="dt">True</span></a></code></pre></div>
<p>So, what happens?! It seems that not only we can assign values several times to <code>it</code> but also that the values could have different types!</p>
<h3 id="dive-in">Dive in</h3>
<p>The question seems very natural, yet there are only a few discussion around it on the Internet. What’s more, it is rather difficult to find such discussions because <code>it</code> is a terrible <a href="https://en.wikipedia.org/wiki/Stop_words">stop word</a>.</p>
<p>It took me a long time before figuring out why (I once even thought that <code>it</code> gets some special treatment in the GHCi implementation). Actually, the mechanism is <strong>very</strong> simple: the <a href="http://book.realworldhaskell.org/read/defining-types-streamlining-functions.html">shadowing</a>.</p>
<p>Consider the following example (taken from Real World Haskell)</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> bar <span class="fu">=</span> <span class="kw">let</span> x <span class="fu">=</span> <span class="dv">1</span> <span class="kw">in</span> ((<span class="kw">let</span> x <span class="fu">=</span> <span class="st">&quot;foo&quot;</span> <span class="kw">in</span> x), x)</a>
<a class="sourceLine" id="cb3-2" title="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> bar</a>
<a class="sourceLine" id="cb3-3" title="3">(<span class="st">&quot;foo&quot;</span>, <span class="dv">1</span>)</a></code></pre></div>
<p>The inner <code>x</code> in the definition of <code>bar</code> <em>shadows</em> the outer <code>x</code>. In particular, though share the same same, they are <strong>not</strong> the same variable and nothing prevents us from assigning different type values to them (in this example, the outer <code>x</code> is <code>Num</code> and the inner <code>x</code> is <code>String</code>).</p>
<p>GHCi actually implements an instance of Monad. In a vanilla Monad, we can do very similar shadowing (with do-syntax)</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="ot">f ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb4-2" title="2">f <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-3" title="3">    <span class="kw">let</span> x <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb4-4" title="4">    <span class="fu">print</span> x</a>
<a class="sourceLine" id="cb4-5" title="5">    <span class="kw">let</span> x <span class="fu">=</span> <span class="st">&quot;foo&quot;</span></a>
<a class="sourceLine" id="cb4-6" title="6">    <span class="fu">print</span> x</a></code></pre></div>
<p>The idea is always the same, the latter <code>x</code> shadows the former <code>x</code> and they are two completely different variables. It is easier to see this in the following <a href="https://en.wikibooks.org/wiki/Haskell/Syntactic_sugar#Do_notation">desugured version</a></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">let</span> x <span class="fu">=</span> <span class="dv">1</span> <span class="kw">in</span> <span class="fu">print</span> x <span class="fu">&gt;&gt;</span> <span class="kw">let</span> x <span class="fu">=</span> <span class="st">&quot;foo&quot;</span> <span class="kw">in</span> <span class="fu">print</span> x</a>
<a class="sourceLine" id="cb5-2" title="2"><span class="dv">1</span></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="st">&quot;foo&quot;</span></a></code></pre></div>
<p>If you actually look at the source code of GHC, what happens is quite similar to what is explained above. Indeed, you can find the following comments</p>
<pre><code>{-
--------------------------------------------------------------------------
                Typechecking Stmts in GHCi
Here is the grand plan, implemented in tcUserStmt
        What you type                   The IO [HValue] that hscStmt returns
        -------------                   ------------------------------------
        let pat = expr          ==&gt;     let pat = expr in return [coerce HVal x, coerce HVal y, ...]
                                        bindings: [x,y,...]
        pat &lt;- expr             ==&gt;     expr &gt;&gt;= \ pat -&gt; return [coerce HVal x, coerce HVal y, ...]
                                        bindings: [x,y,...]
        expr (of IO type)       ==&gt;     expr &gt;&gt;= \ it -&gt; return [coerce HVal it]
          [NB: result not printed]      bindings: [it]
        expr (of non-IO type,   ==&gt;     let it = expr in print it &gt;&gt; return [coerce HVal it]
          result showable)              bindings: [it]
        expr (of non-IO type,
          result not showable)  ==&gt;     error
-}</code></pre>
<p>Basically, when one enters an IO-type expression <code>expr</code>, the expression is evaluated and its value is extracted and bind to <code>it</code></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">print</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="co">-- The expression gets evaluated and () is bond to it, since print 3 :: IO ()</span></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="dv">3</span></a>
<a class="sourceLine" id="cb7-4" title="4"><span class="dt">Prelude</span><span class="fu">&gt;</span> it</a>
<a class="sourceLine" id="cb7-5" title="5">()</a></code></pre></div>
<p>On the other hand, when one enters a non-IO type expression <code>expr</code>, <code>expr</code> gets evaluated and the result is bond to <code>it</code>. <code>it</code> is also printed to screen.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb8-2" title="2"><span class="co">-- The expression gets evaluated and the result 3 is bond to it. `it` also gets printed.</span></a>
<a class="sourceLine" id="cb8-3" title="3"><span class="dv">3</span></a>
<a class="sourceLine" id="cb8-4" title="4"><span class="dt">Prelude</span><span class="fu">&gt;</span> it</a>
<a class="sourceLine" id="cb8-5" title="5"><span class="dv">3</span></a></code></pre></div>
<h3 id="further-reading">Further Reading</h3>
<ul>
<li><p><a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#the-it-variable">The it variable</a> in the <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/index.html">Glasgow Haskell Compiler User’s Guide</a>.</p></li>
<li><p>The <a href="https://github.com/ghc/ghc/blob/master/compiler/typecheck/TcRnDriver.hs">source code</a> where this logic is implemented.</p></li>
</ul>

<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
var disqus_config = function () {
this.page.url = "https://boeingx.github.io/posts/2018-10-21-understanding-the-it-variable-in-ghci.html";  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = this.page.url; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://boeingx.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>


    <div style="clear: both"></div>

    <div id="footer">
        Site proudly generated by
        <a href="https://jaspervdj.be/hakyll">Hakyll</a>.
        The source code of this website is
        <a href="https://github.com/BoeingX/boeingx.github.io">
        available on github</a>.
    </div>
</div>

    </body>
</html>
